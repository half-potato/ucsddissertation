\clearpage
\setcounter{page}{1}
\maketitlesupplementary


\section{Backpropagation}
We use an adjoint rendering approach, starting from the last state of each ray, which we store, and reconstruct each ray state backwards using $p^{-1}(x, i)$. We can then use this reconstructed state to backpropagate the error to each state, then propagate this error to each primitive. The gradient with respect to mean, scale, and orientation, all come from the derivative of the ray-ellipsoid intersection function.  
To retrieve the list of primitives intersected, we store the list of intersections on the forward pass. Since rays tend to terminate before 300 total intersections, this turns out to be relatively cheap, at 1.2 KB per a ray. Although we experimented with using ray tracing to retrieve the list of surfaces in reverse order, we found the instability too high. 


\begin{figure*}[ht]
\centering
\bgroup
% \def\arraystretch{2}
\begin{tabular}{@{}c@{}c@{}c@{}c@{}c@{}}
\graphimtwelve{images/comparison_table_jpg/3DGS_im12.jpg} &
% \graphimtwelve{images/comparison_table_jpg/mcmc_im12.jpg} &
\graphimtwelve{images/comparison_table_jpg/stop_im12.jpg} &
% \graphimtwelve{images/comparison_table_jpg/3dgrt_im12.jpg} &
\graphimtwelve{images/comparison_table_jpg/smerf_im12.jpg} &
\graphimtwelve{images/comparison_table_jpg/ours_im12.jpg} &
\graphimtwelve{images/comparison_table_jpg/gt_im12.jpg} \\
% \raisebox{3.0cm}{\textbf{(b)}} &
\graphimthirteen{images/comparison_table_jpg/3DGS_im13.jpg} &
% \graphimthirteen{images/comparison_table_jpg/mcmc_im13.jpg} &
\graphimthirteen{images/comparison_table_jpg/stop_im13.jpg} &
% \graphimthirteen{images/comparison_table_jpg/3dgrt_im13.jpg} &
\graphimthirteen{images/comparison_table_jpg/smerf_im13.jpg} &
\graphimthirteen{images/comparison_table_jpg/ours_im13.jpg} &
\graphimthirteen{images/comparison_table_jpg/gt_im13.jpg} \\
% \graphimone{images/comparison_table_jpg/3DGS_im1.jpg} &
% \graphimone{images/comparison_table_jpg/mcmc_im1.jpg} &
% \graphimone{images/comparison_table_jpg/stop_im1.jpg} &
% \graphimone{images/comparison_table_jpg/ours_im1.jpg} &
% \graphimone{images/comparison_table_jpg/gt_im1.jpg} \\
\graphimseven{images/comparison_table_jpg/3DGS_im7.jpg} &
% \graphimseven{images/comparison_table_jpg/mcmc_im7.jpg} &
\graphimseven{images/comparison_table_jpg/stop_im7.jpg} &
% \graphimseven{images/comparison_table_jpg/3dgrt_im7.jpg} &
\graphimseven{images/comparison_table_jpg/smerf_im7.jpg} &
\graphimseven{images/comparison_table_jpg/ours_im7.jpg} &
\graphimseven{images/comparison_table_jpg/gt_im7.jpg} \\

\graphimfourteen{images/comparison_table_jpg/3DGS_im14.jpg} &
% \graphimfourteen{images/comparison_table_jpg/mcmc_im14.jpg} &
\graphimfourteen{images/comparison_table_jpg/stop_im14.jpg} &
% \graphimfourteen{images/comparison_table_jpg/3dgrt_im14.jpg} &
\graphimfourteen{images/comparison_table_jpg/smerf_im14.jpg} &
\graphimfourteen{images/comparison_table_jpg/ours_im14.jpg} &
\graphimfourteen{images/comparison_table_jpg/gt_im14.jpg} \\
% \graphimeleven{images/comparison_table_jpg/3DGS_im11.jpg} &
% \graphimeleven{images/comparison_table_jpg/mcmc_im11.jpg} &
% \graphimeleven{images/comparison_table_jpg/stop_im11.jpg} &
% \graphimeleven{images/comparison_table_jpg/ours_im11.jpg} &
% \graphimeleven{images/comparison_table_jpg/gt_im11.jpg} \\

% \graphimtwo{images/comparison_table_jpg/3DGS_im2.jpg} &
% \graphimtwo{images/comparison_table_jpg/mcmc_im2.jpg} &
% \graphimtwo{images/comparison_table_jpg/stop_im2.jpg} &
% \graphimtwo{images/comparison_table_jpg/ours_im2.jpg} &
% \graphimtwo{images/comparison_table_jpg/gt_im2.jpg} \\

% \graphimnine{images/comparison_table_jpg/3DGS_im9.jpg} &
% % \graphimnine{images/comparison_table_jpg/mcmc_im9.jpg} &
% \graphimnine{images/comparison_table_jpg/stop_im9.jpg} &
% \graphimnine{images/comparison_table_jpg/ours_im9.jpg} &
% \graphimnine{images/comparison_table_jpg/gt_im9.jpg} \\
3DGS & StopThePop & SMERF & Ours & GT
\end{tabular}
\egroup
\caption{Additional visual comparison of our method on the Mip-NeRF 360 dataset~\cite{barron2023zip}.}
\label{fig:comparison_supp}
\end{figure*}

\begin{table*}[ht]
    \centering
    \input{tables/zipnerf}
    \caption{Full results for Zip-NeRF dataset}
    % \label{tab:full_zipnerf}
    \centering
    \input{tables/supp_result}
    \caption{Full results for Mip-NeRF 360 dataset}
    \label{tab:full_mipnerf}
\end{table*}

\section{Hyperparameters, Etc} \label{sec:hparams}
We change the opacity learning rate to $0.0125$, the initial position learning rate to $4\times10^{-5}$ and the final position learning rate to $4\times10^{-7}$. We change the parameter known as ``percent dense'' in 3DGS to $0.001785$, which controls the size threshold above which primitives are split instead of cloned. We perform this every 200 iterations, instead of 100, and set the splitting gradient threshold to $2.5\times10^{-7}$ and the clone gradient threshold to $0.1$. We also stop splitting and cloning at 7 million primitives, or at 16000 iterations, which ever comes first, and start at 1500 iterations.

For color, we apply a softplus activation ($\beta=10$) to the output of the spherical harmonics (instead of 3DGS's relu activation), which we find avoids certain local minima where primitives get locked into a color. We increase the spherical harmonic degree every $2,\!000$ iterations, instead of $1,\!000$. We set the max primitive size to $25$ units, which improves performance.


\subsection{Inverse Contraction Initialization}
To help initialize the primitives in a scene, we supplement the SfM initialization with $10,\!000$ additional primitives. We generate these primitives by sampling their means uniformly from a radius-2 sphere. The radius is set to a constant value based the max radius at which the spheres could be packed into the radius-2 sphere, and colors are set to a constant value of $0.5$.
These primitives are then transformed by ``uncontracting'' the resulting means and covariances using the inverse of the contraction used in mip-NeRF 360~\cite{barron2022mip}. We found that highly anisotropic primitives at initialization can cause issues, so we scale the primitives to be isotropic.

To review, the mip-NeRF 360 contraction function $\mathcal{C}$ that maps from a 3D coordinate in Euclidean space $\mathbf{x}$ to a 3D coordinate in contracted space $\mathbf{z}$ is:
\begin{equation}
  \mathcal{C}(\mathbf{x}) = \mathbf{x} \cdot \frac{2 \sqrt{\max(1, || \mathbf{x} ||^2)} - 1}{\max(1, || \mathbf{x} ||^2)}
\end{equation}
The inverse of $\mathcal{C}(\mathbf{x})$ can be defined straightforwardly:
\begin{equation}
    \mathcal{C}^{-1}(\mathbf{z}) = \frac{\mathbf{z}}{\sqrt{\max(1, ||\mathbf{z}||^2)} (2 - \min(2, \sqrt{\max(1, ||\mathbf{z}||^2)}))}
\end{equation}
To apply this inverse contraction to a Gaussian instead of a point, we use the same Kalman-esque approach as was used in mip-NeRF 360: we linearize the contraction around $\mathbf{z}$ into a Jacobian-vector product, which we apply twice to the input covariance matrix.
