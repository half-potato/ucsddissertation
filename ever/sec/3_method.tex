
\newcommand{\figtwowidth}{3.9cm}
\begin{figure*}
    \centering
    \begin{tabular}{@{}c c@{\hspace{3pt}}ccc@{}}
    \includegraphics[width=\figtwowidth,valign=c]{figures/epi_top.png} &
    \raisebox{-10pt}{$\bar{\downarrow}$} &
    \includegraphics[width=\figtwowidth,valign=c]{figures/epi_3dgs.png} &
    \includegraphics[width=\figtwowidth,valign=c]{figures/epi_stp.png} &
    \includegraphics[width=\figtwowidth,valign=c]{figures/epi_ours.png} \\
    \small (a) Top Down View & &
    \small (b) 3DGS~\cite{kerbl20233d} &
    \small (c) StopThePop~\cite{radl2024stopthepop} &
    \small (d) Our Model
    \end{tabular}
    % \includegraphics[width=\textwidth]{figures/simple_epi.pdf}
    \vspace{-3pt}
    \caption{
    (a) Here we show a simple ``flatland'' scene containing two primitives (one red, one blue) with a camera orbiting them, viewed from above.
    We render this orbit using three different techniques, where each camera position yields a one-dimensional ``image'' (a scanline) which are stacked vertically to produce these epipolar plane image (EPI) visualizations.
    (b, c) The approximations made by approximate splatting-based techniques result in improper blending due to discontinuities, which are visible as horizontal lines across the EPI.
    In contrast, (d) our method's exact rendering yields a smooth EPI, with bands of purple from color blending.
    }
    \label{fig:popping_diagram}
\end{figure*}

\section{Motivation}\label{sec:motivation}

\myparagraph{Neural Radiance Fields} 
%Most neural radiance field approaches have been based on using numerical quadrature to integrate the volume rendering formula over a field represented by some kind of function approximator. As such, techniques for speeding up rendering have focused on two things: faster function approximation, and using fewer, but more carefully placed samples (think empty space skipping). However, we ask a different question: 
A radiance field is comprised of two spatially-varying fields as a function of spatial coordinate $\mathbf{x}$: density $\sigma(\mathbf{x})$ and color $c(\mathbf{x}, \mathbf{d})$, where the color field may depend on viewing direction $\mathbf{d}$ in addition to $\mathbf{x}$. A ray with origin $\mathbf{o}$ and direction $\mathbf{d}$ is rendered by integrating these fields using standard volume rendering integral (also known as the radiative transfer equation~\cite{chandrasekhar1960radiative}:
\begin{equation} \label{eqn:volumerendering}
    C = \int_0^\infty c_\mathbf{r}(t)\sigma_\mathbf{r}(t)\exp\lft(-\int_0^t \sigma_\mathbf{r}(s)\,ds\rgt)\,dt \, ,
\end{equation}
where $t$ is distance along a ray, and $\sigma_\mathbf{r}(t) = \sigma(\mathbf{o}+t\mathbf{d})$ and $c_\mathbf{r}(t) = c(\mathbf{o}+t\mathbf{d}, \mathbf{d})$ are the density and color along the ray, respectively.

The parameterization of the density and color fields can vary from small MLPs~\cite{mildenhall2020nerf} to large hierarchies of hashes and grids~\cite{muller2022instant}. Though this approach can produce highly realistic renderings, accurately integrating Equation~\ref{eqn:volumerendering} requires a large number of calls to the underlying field, which means that training and rendering may be slow.

\myparagraph{3D Gaussian Splatting} 
Like NeRF, 3DGS uses alpha compositing to render an image from volumetric primitives, but unlike NeRF it does not directly model a density field. Instead, a collection of Gaussians are projected onto frontoparallel billboards, multiplied by their opacities, sorted, and alpha composited together.
Because this rendering process is data-parallel, 3DGS can be implemented to yield extremely high framerates. However, 3DGS is not 3D consistent;
when the order in which the Gaussians are composed changes, the color abruptly changes as well. This lack of blending is visible as popping artifacts, as can be seen in Figure~\ref{fig:popping_diagram}.


\section{Method}
Like 3DGS, our method takes as input a set of posed images and a sparse point cloud.
We optimize a mixture of ellipsoids (each with a constant density and color) to reproduce the appearance of the input images.
Our method enables \emph{exact} volume rendering. In Section~\ref{sec:rendering} we describe our scene representation and the algorithm for volume rendering it, and in Section~\ref{sec:parameterizing_density} we describe how we optimize it to the input images.


\subsection{Exact Primitive-based Rendering} \label{sec:rendering}

\begin{figure}[b]
    \centering
    \includegraphics[width=0.45\textwidth]{figures/blending_figure.pdf}
    \caption{A visualization of our blending algorithm. 1. We start with our primitives, in this case two, and we are trying to recover the value of the intervals along the ray. 2. We take the change in density and color and sort then from closest to furthest. 3. We sum these changes as we progress through the ray, retrieving the interval values.
    }
    \label{fig:ellipsoid_field}
\end{figure}

We use a simple primitive-based rendering model, where each primitive has a constant density and a single color (in 3D space).
We choose our primitive's shape to be an ellipsoid, which, similar to the Gaussians in 3DGS, is fully characterized by a position vector, rotation quaternion, and scale vector. To model view-dependent color, the ellipsoid's color changes with the view direction, which we store as a spherical function represented by the coefficients for the first two degrees of spherical harmonics.
% Our ellipsoidal primitives are also beneficial due to their computational efficiency in intersection calculations, low memory footprint, and smooth surface geometry. 
% The constant density and color primitives allow us to formulate rendering as the process of tracking how the density field steps up and down along the ray.

\newcommand{\vcolor}{\mathbf{c}}
To render a given ray, we iterate over all front and back surfaces of all primitives intersected by the ray. When we step through the front of a primitive, we add its density $\Delta\sigma_k$ and premultiplied color $\Delta\sigma \Delta\vcolor_k$ to two running totals, $\sigma_i, \hat{\vcolor}_i$. When we step through the back, we subtract the same density and pre-multiplied color. Using these running totals, we can calculate the color $\vcolor_i$ and density $\sigma_i$ for the $i$th interval:
\begin{align}
    \sigma_i = \sum_{k=1}^i \Delta \sigma_k\,, \quad
    \vcolor_i = \frac{1}{\sigma_i} \hat{\vcolor}_i = \frac{1}{\sigma_i} \sum_{k=1}^i \Delta \sigma_k \Delta \vcolor_k\,.
\end{align}
The key here is that this decoupling of the primitive into the front and back allow us to rearrange the surfaces along the ray, as seen in Figure~\ref{fig:ellipsoid_field}. In this example, we can see two overlapping primitives. In 3DGS, we would simply render A and B separately, ignoring their overlap, and then combine them. In contrast, our method allows rendering this representation exactly by computing the density and color at the three intervals A, A+B, and B, by tracking their changes as we progress through the ray.
Since color and density are constant within each interval of length $\Delta t_i$ between consecutive intersection points, there is a simple closed-form solution to the volume rendering equation:
\begin{equation}
    \vcolor_i (1-\exp(-\sigma_i \Delta t_i)) \,,\label{eqn:closed form}
\end{equation}
By tracking the running total and the distance between the intersection steps, $\Delta t_i$, we are able to integrate the volume rendering equation exactly by alpha compositing these simple segments, as follows:
\begin{equation}
    C = \sum_{i=1}^N \vcolor_i (1-\exp(-\sigma_i \Delta t_i)) \prod_{j=1}^{i-1} \exp(-\sigma_j \Delta t_j)\,.\label{eqn:alphacomp}
\end{equation}
Unsurprisingly, the expression in Equation~\ref{eqn:alphacomp} is identical to the quadrature rule derived by Max~\cite{max1995optical}, which uses a piecewise-constant approximation to density and color --- though in our case this piecewise-constant property is an intentional design decision, not an approximation. Our work uses this closed-form solution to enable real-time rendering of the entire collection of ellipsoids without introducing any approximation errors which may cause artifacts.
 
% We can easily track the derivative of the radiance field because our selection of model is piecewise-constant in 3D. This means that the density and color along any ray are also piecewise constant, and they can be written in the following step function form with coefficients $\sigma_i, c_i$ respectively:
% \begin{align}
%     \sigma(t) &= \sum_{i=1}^N \sigma_i \mathbbm{1}[t_i \leq t < t_{i+1}]\,, \\
%     \vcolor(t) &= \sum_{i=1}^N \vcolor_i\mathbbm{1}[t_i \leq t < t_{i+1}]\,,\label{eqn:color}
% \end{align}
% where $\mathbbm{1}[\cdot]$ is an indicator function whose value is $1$ when the condition in the brackets is met and $0$ otherwise, and $\{t_i\}_{i=1}^N$ are the density discontinuities, which are found by intersecting the ray with the primitives. The density and color coefficients for the $i$th interval, $t \in [t_i, t_{i+1})$, can be determined by combining the contributions of each primitive along the ray:
% \begin{align}
%     \sigma_i = \sum_{k=1}^i \Delta \sigma_k\,, \quad
%     \vcolor_i = \frac{1}{\sigma_i} \sum_{k=1}^i \Delta \sigma_k \Delta \vcolor_k\,,
% \end{align}
% where $\Delta\sigma_k$ and $\Delta \vcolor_k$ are the changes in density and color at the $k$th intersection point of the ray with the primitives in the scene, respectively. Note that $\Delta\sigma_k$ is positive when entering a primitive and negative when exiting one. Now, the volume rendering integral from Equation~\ref{eqn:volumerendering} can be computed \emph{exactly}:
% \begin{equation}
%     C = \sum_{i=1}^N \vcolor_i (1-\exp(-\sigma_i \Delta t_i)) \prod_{j=1}^{i-1} \exp(-\sigma_j \Delta t_j)\,,\label{eqn:alphacomp}
% \end{equation}
% Unsurprisingly, the expression in Equation~\ref{eqn:alphacomp} is identical to the quadrature rule derived by Max~\cite{max1995optical} that also makes a piecewise-constant approximation to density and color --- though in our case this piecewise-constant property is an intentional design decision, not an approximation.

%A constant density ellipsoid's ability to express both soft and hard falloffs appears to contribute to our model's expressive power, similarly to the effect demonstrated by Hamdi \etal~\cite{hamdi2024ges}. 



\begin{figure}
    \centering
    \includegraphics[width=0.45\textwidth]{figures/alpha_profiles.pdf}
    \caption{Here we show 1D screen-space slices of rendered opacity profiles for different rendering methods, to demonstrate one advantage of our density-based parameterization. We show 3 different peak opacities and their profiles, where solid lines represent our density based ellipsoid primitives and dashed lines represent 3DGS. For our model we show densities $\sigma \in \{1, 3, 100\}$, while for 3DGS we compute the corresponding peak opacity such that each slice has the same maximum opacity as our model. While Gaussians always have smooth opacity profiles that limit their ability to reproduce edges in image space, our opacity profiles can be smooth ($\sigma = 1$) or sharp ($\sigma = 100$).} 
    \label{fig:alpha_profiles}
\end{figure}

% \myparagraph{Constant Density Ellipsoids} 
%\subsection{Constant Density Ellipsoids} 
% Our model lies in between NeRF and 3DGS: like NeRF we perform 3D consistent volume rendering of a radiance field, but like 3DGS we parameterize the scene using a collection of anisotropic primitives.
% Instead of Gaussians as primitives we use constant density ellipsoids, which we can volume render \emph{exactly} without any numerical quadrature (and \emph{efficiently} thanks to decades of progress in ray tracing).
Note that although our scene representation looks superficially similar to that of 3DGS, it is different in two key ways: First, while 3DGS Gaussians are treated as 2D ``billboards'', our ellipsoids blend together so as to constitute a proper and consistent 3D radiance field. Second, while the 2D opacity profile of the primitives used in 3DGS always has a smooth Gaussian falloff, the 2D opacity profile of one of our ellipsoidal primitives can range from extremely smooth to a perfect step function in the limit of infinite density. See Figure~\ref{fig:alpha_profiles} for examples of our primitive's opacity profiles for different density values. 
% To highlight the difference between our method, 3DGS, StopThePop, and traditional NeRF, we render the same 3 colorful ellipsoids with all 4 methods on the right side of Figure~\ref{fig:frontpage}. When the primitives are sorted per a view, the color between the primitives do not mix to produce purple, yellow, and blue green, but the appearance is smooth. When the primitives are sorted per a ray, the order changes throughout the image, causing lines to appear. Because our rendering model is exact, the rendering from our model exactly matches the ground truth.
\subsection{Optimization} \label{sec:parameterizing_density}

Our optimization framework is built on top of 3DGS, where instead of rasterizing Gaussians we ray trace and volume render our ellipsoid-based representation using the method described in Section~\ref{sec:rendering}. In particular, we reuse the Adaptive Density Control (ADC) introduced in 3DGS, with some modifications for our density-based primitives.

% To isolate the effects of our novel rendering method, we build our optimization on the 3DGS framework, using minimal changes to help handle density based primitives, including changes to the Adaptive Density Control (ADC).
The first, essential change is to convert from the 3DGS opacity framework to a density framework.
The naive approach would be to assign each primitive a density instead of opacity, but this presents a challenge. As the  density of a primitive grows and its opacity approaches $1$, the gradient used for updating the parameters of the primitive approaches $0$ and would require special treatment~\cite{li2018differentiable}. Intuitively, this is because the outside of the primitive becomes opaque.

We avoid this problem by optimizing over a parameter $\alpha_k$ which is mapped to density value used during rendering:
\begin{equation}
    \sigma(\alpha_k) = -\frac{\log(1-0.99 \cdot \alpha_k)}{\min(s_{kx}, s_{ky}, s_{kz})}\, .
\end{equation}
With this, a primitive with density $\sigma(\alpha_k)$ when viewed along its shortest axis will have a peak opacity equal to $\alpha_k$, ensuring at least one view will have non-zero gradient.

Finally, we add an additional splitting condition: We split primitives if the opacity is near 1 across the entire primitive when viewed from the major axis to see if the gradient has vanished using the following test:
\begin{equation}
    0.99 < 1 - \exp\lft(-\sigma(\alpha_k) \cdot \max\lft(s_{kx}, s_{ky}, s_{kz}\rgt)\rgt)\,.
\end{equation}